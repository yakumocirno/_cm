# 微積分基本定理（Theorem 1）數值驗證

## 問題說明

本程式的目的是**利用數值方法驗證微積分基本定理第一部分**：

> 若函數 ( f(x) ) 在區間內連續，則
> [
> \frac{d}{dx} \left( \int_0^x f(t),dt \right) = f(x)
> ]

也就是說：

* 先對函數做「定積分（從 0 到 x）」
* 再對積分結果做微分
* 應該會得到原本的函數 ( f(x) )

本程式使用 **數值微分** 與 **數值積分** 來近似上述過程，並計算誤差。

---

## 解題思路

### 1️⃣ 數值微分（中央差分法）

微分定義為極限：
[
f'(x) = \lim_{h \to 0} \frac{f(x+h)-f(x-h)}{2h}
]

在程式中使用固定且足夠小的 ( h = 10^{-6} )，以「中央差分法」近似微分：

```python
def df(f, x, h=1e-6):
    return (f(x + h) - f(x - h)) / (2 * h)
```

中央差分法比單邊差分更準確，誤差階為 ( O(h^2) )。

---

### 2️⃣ 數值積分（梯形法）

將區間 ([a, b]) 分成 ( n ) 等分，每一小段用梯形近似面積：

[
\int_a^b f(x)dx \approx h\left[ \frac{f(a)+f(b)}{2} + \sum_{i=1}^{n-1} f(a+ih) \right]
]

對應程式如下：

```python
def integral(f, a, b, n=10000):
    h = (b - a) / n
    s = 0.5 * (f(a) + f(b))
    for i in range(1, n):
        s += f(a + i * h)
    return s * h
```

使用較大的 `n = 10000` 以提高積分近似的準確度。

---

### 3️⃣ 驗證微積分基本定理

定義函數：
[
F(x) = \int_0^x f(t)dt
]

接著比較：

* 左邊：( \frac{d}{dx} F(x) )（數值微分）
* 右邊：( f(x) )（原函數）

若微積分基本定理成立，兩者應非常接近。

對應程式：

```python
def theorem1(f, x):
    left = df(lambda t: integral(f, 0, t), x)
    right = f(x)
    print("x =", x)
    print("d/dx ∫₀ˣ f(t)dt ≈", left)
    print("f(x) =", right)
    print("誤差 =", abs(left - right))
    print("-" * 30)
```

---

## 測試函數與測試點

選擇簡單且連續的函數：
[
f(x) = x^2
]

測試點：

* ( x = 0.5 )
* ( x = 1.0 )
* ( x = 2.0 )

程式會輸出每個測試點的：

* 微分後的積分值（近似）
* 原函數值
* 兩者的誤差

---

## 結果與結論

從輸出結果可觀察到：

* ( \frac{d}{dx} \int_0^x f(t)dt ) 與 ( f(x) ) 數值上非常接近
* 誤差極小，主要來自數值微分與數值積分的近似誤差

✅ 這驗證了 **微積分基本定理第一部分在數值計算下仍然成立**。

---

## 總結

本程式結合：

* 中央差分法（數值微分）
* 梯形法（數值積分）

成功以程式方式驗證微積分中的重要理論，並幫助理解「微分與積分互為反運算」的概念。
