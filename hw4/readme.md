# [AI對話](https://chatgpt.com/share/6959682e-a8d8-8005-aaf4-4ba3a0a4ecd3)
# README — 用爬山法（Hill Climbing）找多項式的一個根

本專案目標：對任意複係數多項式  
\[
p(z)=\sum_{i=0}^{n} c[i]\;z^i
\]
在沒有封閉解（特別是 \(n\ge 5\)）的前提下，用數值法在複平面上找出「至少一個」使 \(|p(z)|\) 足夠小的點，視為多項式的一個根。

---

## 核心想法

把「找根」改寫成「最小化目標函數」：

- 真正的根滿足 \(p(z)=0\)  
- 所以可以最小化 \(f(z)=|p(z)|\)（或 \(|p(z)|^2\) 也可以）

此程式採用 **爬山演算法（其實是爬「下降」）**：
- 每一步在目前點 \(z\) 的鄰域隨機挑幾個候選點 \(z+\Delta z\)
- 若候選點使 \(|p(z)|\) 下降，就接受移動
- 若多次嘗試都沒有變好，就縮小步長
- 若步長縮到很小仍卡住，就重新隨機初始化（restart）

這是「隨機局部搜尋 + 自適應步長 + 多次重啟」的組合，用來對付複平面上常見的局部平坦或局部谷地問題。

---

## 演算法流程（對應 `find_one_root_hill`）

### 1. 搜尋範圍：Cauchy Bound

先用 `cauchy_bound(c)` 算出一個半徑 \(R\)，保證所有根都在 \(|z|\le R\) 的圓盤內。  
因此初始化與步長尺度都用 \(R\) 來正規化，避免不同多項式尺度差異太大。

### 2. 多次重啟（restarts）

外層做 `restarts` 次（預設 60 次）：

- 每次都在半徑 \(R\) 的圓盤中隨機選一個起點 \(z\)
- 用極座標抽樣：  
  - \(\theta\sim U[0,2\pi)\)
  - \(r = R\sqrt{u}\)（用 \(\sqrt{u}\) 讓點在圓盤「面積均勻」）

> 為什麼用 \(r=R\sqrt{u}\)？  
> 若直接 \(r=Ru\)，點會偏向圓心；用 \(\sqrt{u}\) 才會均勻灑在整個圓盤面積上。

### 3. 內層迭代：隨機鄰域改善

- 初始步長 `step = 0.2 * R`
- 每回合算目前值 `val = abs(p(z))`
  - 若 `val < tol` 直接回傳 `z`

接著在目前點附近嘗試 20 個隨機鄰居：
- \(\Delta z\) 的實部、虛部分別在 \([-\frac{step}{2},\frac{step}{2}]\) 均勻取樣
- 若找到任何一個鄰居 \(z_2\) 使得 \(|p(z_2)| < |p(z)|\)，就接受並更新 \(z=z_2\)

這種「先找到先接受」的策略：
- 優點：快、實作簡單
- 缺點：不保證選到當下 20 個候選中最好的點（但通常夠用）

### 4. 卡住時：縮步長或放棄本次 restart

若 20 次都找不到更好的鄰居：
- 視為卡住，縮小步長：`step *= 0.7`
- 若步長縮到 `step < 1e-10 * R`，認定這次 restart 走不下去，跳出、進入下一次 restart

### 5. 最佳備援解（best_z）

即使沒有達到 `tol`，程式會一路記錄目前遇過的最小 `best_val` 與對應 `best_z`。  
最後若所有重啟都失敗，回傳 `best_z` 作為「最接近根的點」。

---

## 為什麼不用導數（Newton）？

你在程式中仍呼叫 `poly_and_derivative(c, z)`，但這個版本的 hill-climbing **沒有直接使用導數方向**，原因通常是：

- Newton 法收斂很快但需要良好初始點，且在導數接近 0 或遠離根時可能發散
- 爬山法更「粗魯但穩健」，用隨機探索避免卡在不良區域
- 可以把此法當成「先粗找到一個不錯的點」，再切 Newton 做精修（可作為延伸改進）

---

## 參數設定與影響

- `tol`：根的判定門檻，越小越嚴格、越難達成
- `max_iter`：每次 restart 的最大迭代步數
- `restarts`：重啟次數，越大越有機會找到根，但時間增加
- 鄰居嘗試次數（固定 20）：越大越容易找到改善點，但每步成本變大
- `step` 初值與縮小倍率（0.2R、*0.7）：
  - 初值太大：可能跳來跳去不穩
  - 初值太小：探索慢、容易陷局部
  - 縮小太快：容易過早卡死
  - 縮小太慢：浪費在無效的大範圍亂試

---

## 正確性與限制

### 能做到的事
- 在多次隨機重啟下，通常能找到一個使 \(|p(z)|\) 很小的點
- 對於複根也同樣適用（在複平面上直接搜尋）

### 不能保證的事
- **不保證一定找到真正的根**（只能做到「很接近」）
- **不保證找到所有根**：此函數目標是「一個根」，不是全部
- 對於極端病態多項式（係數尺度差異巨大、根非常靠近、條件數差），可能需要：
  - 更好的縮放/正規化
  - 更好的候選分佈
  - 或改用 Newton / Durand–Kerner / Aberth 等專用方法

---

## 建議的延伸改進（可選）

1. **混合 Newton 精修**  
   hill-climbing 找到 `best_z` 後，用 Newton 迭代幾步通常可顯著提升精度。

2. **改用目標函數 \(|p(z)|^2\)**  
   避免 `abs` 的非解析性，但本程式用隨機比較其實差異不大。

3. **加入退火（Simulated Annealing）**  
   允許偶爾接受變差的點，提升跳出局部極小值的能力。

4. **對找到的根做 deflation**  
   找到一根後用多項式除法降低次數，重複找下一根（要注意數值穩定性）。

---

## 使用方式（範例）

```python
# c[i] 是 z^i 的係數
# 例：p(z)=z^3-1 => c=[-1,0,0,1]
z0 = find_one_root_hill(c, tol=1e-10, max_iter=200000, restarts=60)

p0, _ = poly_and_derivative(c, z0)
print("root approx:", z0)
print("|p(root)|   :", abs(p0))
